# Наследяване

- създаване на нови обекти чрез директно придобиване на атрибутите и поведението на други обекти и последващото им разширяване или специализиране
- класът, който бива наследен, се нарича родителски (parent) клас, базов (base) клас или (superclass) суперклас
- класът, който наследява, се нарича клас наследник (child), производен (derivative) клас или подклас (subclass)
- is-a relationship (triangle is a shape)
- наследяват се член-данните и методите на базовия клас
- получава се достъп до **някои** от наследените компоненти на базовия клас (public и protected)

![Class Hierarchy](http://learncpp.com/images/CppTutorial/Section11/ShapesInheritance.gif)

### Single (единично)
- нов клас се създава от един друг клас
### Multiple (множествено)
- нов клас се създава от два (или повече) други класа

## Inheritance vs Composition
| Наследяване   | Композиция     |
| :---:   | :---: |
| is-a | has-a |
| Oбект придобива характеристиките на един или повече други обекти | Обект използва вътре в друг обект |
| Дефиниран по време на компилиране - Compile time | Дефиниран по време на изпълнение - Runtime |
| Има достъп до public и protected данни на базовия клас| Вътрешните данни не са достъпни, а взаимодействат чрез публичен интерфейс |

## Видове наследяване
- private (по подразбиране)
- protected
- public

```c++
class A  {
public:
    int x;
protected:
	int y;
private:
    int z;
};

class B : public A {
    // x is public
    // y is protected
    // z is not accessible from B
};

class C : protected A {
    // x is protected
    // y is protected
    // z is not accessible from C
};

class D : private A { // 'private' is default for classes
    // x is private
    // y is private
    // z is not accessible from D
};
 ```

## Пример
```c++
class A {
public:
    void f() {
	}
};

class B : public A {
}

int main() {
	B obj;
	obj.f();
}
```
- клас B използва логиката от клас А, затова можем да си спестим предефинирането на същата логика, като използваме наследяване
- след като В е наследник на класа А, то при създаване на обект от тип В се създава обект от тип А, който е част от обекта от тип В (в началото на обекта от тип B)

## Подаване като параметри на функции
- класове-наследници могат да бъдат подавани като параметри на функции, които приемат обекти от базовия клас - по копие, референция или указател
- това е така, защото наследника съдържа в себе си родителя - този вътрешен обект се подава на функцията
- тя не знае за останалата чат от налседника, затова може да се използва функционалността само от родителя
- обратното не е валидно!

```c++
class A {};
class B : public A {};

void f(A obj) {}
void g(A& obj) {}
void h(A* obj) {}
void k(B& obj) {}

int main() {
	A obj1;
	B obj2;

	f(obj1); //OK!
	f(obj2); //OK!

	g(obj1); //OK!
	g(obj2); //OK!

	h(&obj1); //OK!
	h(&obj2); //OK!

	k(obj1); //Error!
	k(obj2); //OK!
}
 ```

 ## Голяма шестица при наследяване

 ### Конструктури и деструктори при наследяване

- тъй като всеки наследник има в началото си обект от базовия  клас, при създаване на обект от наследника винаги се вика **първо конструктора на базовия клас**
- ако не е оказано кой конструктор да се извика, ще се извика конструкторът по подразбиране
- деструкторите се викат в обратен ред на конструкторите - **налседникът първо изтрива собствените си данни** и после се вика деструктора на базовия клас (по подразбиране)

### Копиране при наследяване

- При разписване на копи конструктора и оператора= на клас-наследник, трябва експлицитно да извикваме копиране и за базовия клас

 ```c++
B::B(const B& other) : A(other) { //copy constructor of A
	copyFrom(other);
}

B& B::operator=(const B& other) {
	if (this != &other) {
	    A::operator=(other); //operator= of A
	    free();
	    copyFrom(other);
	}
	return *this;
}
 ```

- Ако **не** ги дефинирате в класа наследник, компилаторът **ще ги създаде автоматично**
- Ако ги дефинираме в класа наследник, **трябва изрично** да се извикат базовите - иначе ще се извика дефолтен конструктор на базовия в копиращия на наследника, а в оператор= нищо няма да се извика

### Move семантики

```c++
B::B(B&& other) : A(std::move(other)) { //move constructor of A
    moveFrom(std::move(other));
}

B::B& operator=(B&& other) {
    if (this != &other) {
        A::operator=(std::move(other)); //move operator= of A
        free();
        moveFrom(std::move(other));
    }
    return *this;
}
```
